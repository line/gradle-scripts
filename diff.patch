diff --git a/README.md b/README.md
index 2e3f8cada..2f849be87 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 The scripts here provides a simple way to configure a Java project with
 sensible defaults. By applying them, you can:
 
-- Manage dependencies using a simple YAML file.
+- Manage dependencies using a simple TOML file that is fully compatible with [Gradle version catalogs](https://docs.gradle.org/current/userguide/platforms.html).
 - Configure Checkstyle and JaCoCo code coverage.
 - Add [Javadoc offline links](https://docs.oracle.com/javase/9/javadoc/javadoc-command.htm#GUID-51213F2C-6E01-4A03-A82A-17428A258A0F) easily.
 - Add Google Analytics scripts into Javadoc if `googleAnalyticsId` property exists.
@@ -122,47 +122,56 @@ sensible defaults. By applying them, you can:
 
 ## Dependency management
 
-Put your dependency versions into `<project_root>/dependencies.yml` so you don't
-need to put the version numbers in `build.gradle`:
+Put your dependency versions into `<project_root>/dependencies.toml` so you don't
+need to put the version numbers in `build.gradle`.
+The `dependencies.toml` file supports the same syntax as Gradle's [`libs.versions.toml`](https://docs.gradle.org/current/userguide/platforms.html#sub:conventional-dependencies-toml).
+In addition, it also supports additional properties such as:
+- `boms`: A table to manages a list of BOM dependencies.
+- `relocations`: A table or an array of tables to relocate specific dependencies to a new location.
+- `exclusions`: A string or an array of strings to exclude specific dependencies from the module.
+- `javadocs`: A string or an array of strings to link to external Javadocs.
+
+```toml
+# Import 'armeria-bom':
+[boms]
+armeria = { module = "com.linecorp.armeria:armeria-bom", version = "1.17.0" }
 
-```yaml
 # Simple form:
-com.google.code.findbugs:
-  jsr305: { version: '3.0.2' }
+[libraries]
+findbugs = { module = "com.google.code.findbugs:jsr305", version = '3.0.2' }
 
 # Slightly more verbose, but useful when an artifact has more than one property:
-com.google.guava:
-  guava:
-    version: '30.1.1-jre'
-    exclusions:
-      - com.google.code.findbugs:jsr305
-      - com.google.errorprone:error_prone_annotations
-      - com.google.j2objc:j2objc-annotations
-      - org.codehaus.mojo:animal-sniffer-annotations
-
-# More than one artifact under the same group:
-com.fasterxml.jackson.core:
-  jackson-annotations:
-    version: &JACKSON_VERSION '2.12.2' # Using a YAML anchor
-    javadocs:
-      - https://fasterxml.github.io/jackson-annotations/javadoc/2.12/
-  jackson-core:
-    version: *JACKSON_VERSION
-    javadocs:
-      - https://fasterxml.github.io/jackson-core/javadoc/2.12/
-  jackson-databind:
-    version: *JACKSON_VERSION
-    javadocs:
-      - https://fasterxml.github.io/jackson-databind/javadoc/2.12/
+[libraries.guava]
+module = "com.google.guava:guava"
+version = '31.1.1-jre'
+exclusions = [
+  "com.google.code.findbugs:jsr305",
+  "com.google.errorprone:error_prone_annotations",
+  "com.google.j2objc:j2objc-annotations",
+  "org.codehaus.mojo:animal-sniffer-annotations"]
+relocations = [
+  { from = "com.google.common", to = "com.linecorp.armeria.internal.shaded.guava" },
+  { from = "com.google.thirdparty.publicsuffix", to = "com.linecorp.armeria.internal.shaded.publicsuffix" }]
+
+[versions]
+reactor = "3.4.19"
+
+[libraries.reactor-core]
+module = "io.projectreactor:reactor-core"
+# Reference the version declared in `[versions]`:
+version.ref = "reactor"
+javadocs = "https://projectreactor.io/docs/core/release/api/"
+[libraries.reactor-test]
+module = "io.projectreactor:reactor-test"
+version.ref = "reactor"
 ```
 
-Gradle's dependency resolution strategy will be automatically configured as
-specified in `dependencies.yml`, so you don't have to specify version numbers
-in `build.gradle`:
+Dependencies declared in `dependencies.toml` are exposed to build scripts via an extension corresponding to 
+their name. 
 
 ```groovy
 plugins {
-    id 'com.google.osdetector' version '1.6.2' apply false
+    alias libs.plugins.osdetector apply false
 }
 
 allprojects {
@@ -177,23 +186,31 @@ apply from: "${rootDir}/gradle/scripts/build-flags.gradle"
 configure(projectsWithFlags('java')) {
     // Common dependencies
     dependencies {
-        compileOnly 'com.google.code.findbugs:jsr305'
-        compile 'com.google.guava:guava'
+      compileOnly libs.findbugs
+      implementation libs.guava
     }
 }
 
 // In case you need to get the version number of an artifact:
+println "Guava version: ${libs.guava.get().versionConstraint.requiredVersion}"
+// Note that it is not recommended to use `managedVersions` with the module defined multiple times with 
+// different aliases. Because if a module is declared with different versions, the version returned by 
+// `managedVersions` is determined by how the version catalogs are indexed.
 println "Guava version: ${managedVersions['com.google.guava:guava']}"
 ```
 
 ### Importing Maven BOM (Bill of Materials)
 
-At `dependencies.yml`, you can add a special section called `boms` to specify
+At `dependencies.toml`, you can add a special section called `boms` to specify
 the list of Maven BOMs to import:
 
-```yaml
-boms:
-- io.spring.platform:platform-bom:2.0.8.RELEASE
+```toml
+[boms]
+armeria = { module = "com.linecorp.armeria:armeria-bom", version = "1.17.0" }
+
+# A dependency that uses the version defined in 'armeria-bom'.
+[libraries.armeria]
+module = "com.linecorp.armeria:armeria"
 ```
 
 ### Checking if dependencies are up-to-date
@@ -298,7 +315,7 @@ automatically:
 
 - `java` - Makes a project build a Java source code
 - `publish` - Makes a project publish its artifact to a Maven repository
-- `bom` - Makes a project publish Maven BOM based on `dependencies.yml`
+- `bom` - Makes a project publish Maven BOM based on `dependencies.toml`
 - `shade`, `relocate` and `trim` - Makes a Java project produce an additional 'shaded' JAR
 - `reactor-grpc` or `rxgrpc` - Enables [`reactor-grpc`](https://github.com/salesforce/reactive-grpc/tree/master/reactor) or [`rxgrpc`](https://github.com/salesforce/reactive-grpc/tree/master/rx-java) support to the project
 
@@ -331,10 +348,10 @@ When a project has a `java` flag:
       such as static analysis.
   - A special configuration property `checkstyleConfigDir` is set so you can
     access the external files such as `suppressions.xml` from `checkstyle.xml`.
-  - You can choose Checkstyle version by specifying it in `dependencies.yml`:
-    ```yaml
-    com.puppycrawl.tools:
-      checkstyle: { version: '8.5' }
+  - You can choose Checkstyle version by specifying it in `dependencies.toml`:
+    ```toml
+    [libraries]
+    checkstyle = { module = "com.puppycrawl.tools:checkstyle", version = "10.3.1" }
     ```
   - Checkstyle can be disabled completely by specifying `-PnoLint` option.
 
@@ -357,24 +374,23 @@ When a project has a `java` flag:
 
 - [Jetty ALPN agent](https://github.com/jetty-project/jetty-alpn-agent) is
   loaded automatically when launching a Java process if you specified it in
-  `dependencies.yml`:
+  `dependencies.toml`:
 
-  ```yaml
-  org.mortbay.jetty.alpn:
-    jetty-alpn-agent: { version: '2.0.10' }
+  ```toml
+  [libraries] 
+  jetty-alpn = { module = "org.mortbay.jetty.alpn:jetty-alpn-agent", version = "2.0.10" }
   ```
 
-- The `package-list` files of the Javadocs specified in `dependencies.yml` will
+- The `package-list` files of the Javadocs specified in `dependencies.toml` will
   be downloaded and cached. The downloaded `package-list` files will be used
-  when generating Javadocs, e.g. in `dependencies.yml`:
-
-  ```yaml
-  io.grpc:
-    grpc-core:
-      version: &GRPC_VERSION '1.36.1'
-      javadocs:
-        - https://grpc.io/grpc-java/javadoc/
-        - https://developers.google.com/protocol-buffers/docs/reference/java/
+  when generating Javadocs, e.g. in `dependencies.toml`:
+
+  ```toml
+  [libraries.grpc-core]
+  module = "io.grpc:grpc-core"
+  version = "1.47.0"
+  javadocs = [ "https://grpc.io/grpc-java/javadoc/",
+               "https://developers.google.com/protocol-buffers/docs/reference/java/" ]
   ```
 
   If you are in an environment with restricted network access, you can specify
@@ -388,10 +404,20 @@ When a project has a `java` flag:
     - Consider adding dependency tasks to the `generateSources` task to do
       other source generation jobs.
   - You need to add `com.google.protobuf:protobuf-gradle-plugin` to
-    `dependencies.yml` to get this to work.
-  - Add `com.google.protobuf:protoc` to `dependencies.yml` to specify the
+    `dependencies.toml` to get this to work.
+  - Add `com.google.protobuf:protoc` to `dependencies.toml` to specify the
     compiler version.
   - Add `io.grpc:grpc-core` if you want to add gRPC plugin to the compiler.
+  
+    ```toml
+    [libraries.protobuf-gradle-plugin]
+    module = "com.google.protobuf:protobuf-gradle-plugin"
+    version = "0.8.18"
+
+    [libraries.protobuf-protoc]
+    module = "com.google.protobuf:protoc"
+    version = "3.19.2"
+    ```
 
 - The `.thrift` files under `src/*/thrift` will be compiled into Java code.
 
@@ -479,7 +505,7 @@ $ ./gradlew test -PbuildJdkVersion=15 -PtestJavaVersion=8
 ## Generating Maven BOM with `bom` flag
 
 If you configure a project with `bom` flag, the project will be configured to
-generate Maven BOM based on the dependencies specified in `dependencies.yml`.
+generate Maven BOM based on the dependencies specified in `dependencies.toml`.
 
 `bom` flag implies `publish` flag, which means the BOM will be uploaded to a
 Maven repository by `./gradlew publish`.
@@ -501,18 +527,15 @@ apply from: "${rootDir}/gradle/scripts/settings-flags.gradle"
 includeWithFlags ':foo', 'java', 'shade'
 ```
 
-You need to add `relocations` property to `dependencies.yml` to tell which
+You need to add `relocations` property to `dependencies.toml` to tell which
 dependency needs shading:
 
 ```yaml
-com.google.guava:
-  guava:
-    version: '17.0' # What an ancient dependency!
-    relocations:
-    - from: com.google.common
-      to: com.doe.john.myproject.shaded.guava
-    - from: com.google.thirdparty.publicsuffix
-      to: com.doe.john.myproject.shaded.publicsuffix
+[libraries.guava]
+module = "com.google.guava:guava"
+version = "17.0" # What an ancient dependency!
+relocations [ { from: "com.google.common", to: "com.doe.john.myproject.shaded.guava" },
+              { from: "com.google.thirdparty.publicsuffix", to: "com.doe.john.myproject.shaded.publicsuffix" } ]
 ```
 
 ### Trimming a shaded JAR with `trim` flag
diff --git a/build-flags.gradle b/build-flags.gradle
index 63f55258a..a7982872f 100644
--- a/build-flags.gradle
+++ b/build-flags.gradle
@@ -1,7 +1,12 @@
 def libDir = new File(buildscript.sourceFile.parentFile, 'lib')
 
 apply from: "${libDir}/prerequisite.gradle"
-apply from: "${libDir}/common-dependencies.gradle"
+if (rootProject.ext.hasDependenciesToml) {
+    apply from: "${libDir}/common-dependencies.gradle"
+} else {
+    // 'dependencies.yml' is deprecated in favor of 'dependencies.toml'
+    apply from: "${libDir}/common-dependencies-legacy.gradle"
+}
 apply from: "${libDir}/common-git.gradle"
 apply from: "${libDir}/common-info.gradle"
 apply from: "${libDir}/common-publish.gradle"
@@ -23,7 +28,7 @@ if (!projectsWithFlags('java').isEmpty()) {
     if (projectsWithFlags('java').find { it.ext.hasSourceDirectory('proto') }) {
         if (!managedVersions.containsKey('com.google.protobuf:protobuf-gradle-plugin')) {
             throw new IllegalStateException(
-                    "com.google.protobuf:protobuf-gradle-plugin must be specified in dependencies.yml " +
+                    "com.google.protobuf:protobuf-gradle-plugin must be specified in dependencies.(toml|yml) " +
                     "to compile .proto files.")
         }
         apply from: "${libDir}/java-rpc-proto.gradle"
@@ -33,7 +38,7 @@ if (!projectsWithFlags('java').isEmpty()) {
         ['com.github.jengelman.gradle.plugins:shadow', 'com.guardsquare:proguard-gradle'].each {
             if (!managedVersions.containsKey(it)) {
                 throw new IllegalStateException(
-                        "${it} must be specified in dependencies.yml to use the 'relocate' flag.")
+                        "${it} must be specified in dependencies.(toml|yml) to use the 'relocate' flag.")
             }
         }
         apply from: "${libDir}/java-shade.gradle"
diff --git a/lib/common-dependencies-legacy.gradle b/lib/common-dependencies-legacy.gradle
new file mode 100644
index 000000000..a363e663a
--- /dev/null
+++ b/lib/common-dependencies-legacy.gradle
@@ -0,0 +1,267 @@
+import org.yaml.snakeyaml.Yaml
+
+buildscript {
+    repositories {
+        mavenCentral()
+        gradlePluginPortal()
+    }
+
+    dependencies {
+        // These should be the only dependencies that need hard-coded versions.
+        classpath 'com.github.ben-manes:gradle-versions-plugin:0.39.0'
+        classpath 'org.yaml:snakeyaml:1.29'
+    }
+}
+
+rootProject.ext {
+    def dependenciesYamlFile = new File("${project.projectDir}/dependencies.yml")
+    if (dependenciesYamlFile.exists()) {
+        dependenciesYaml = Collections.unmodifiableMap(new Yaml().loadAs(dependenciesYamlFile.text, Map))
+    } else {
+        dependenciesYaml = Collections.emptyMap()
+    }
+}
+
+def managedDependencyVersions = new TreeMap<String, String>() {
+    @Override
+    String get(Object key) {
+        def value = super.get(key)
+        if (value != null) {
+            return value
+        } else {
+            throw new IllegalArgumentException("Missing managed dependency: ${key}")
+        }
+    }
+}
+def managedDependencyExclusions = [:].withDefault { [] }
+def managedDependencyOverrides = [] as Set
+rootProject.ext.dependenciesYaml.forEach { String key, value ->
+    if (key == 'boms') {
+        value.each {
+            def parsed = it.split(':')
+            managedDependencyVersions["${parsed[0]}:${parsed[1]}"] = parsed[2]
+        }
+    } else {
+        def groupId = key
+        def artifact = value as Map
+        artifact.forEach { String artifactId, Map props ->
+            if (props.containsKey('version')) {
+                managedDependencyVersions["${groupId}:${artifactId}"] = String.valueOf(props['version'])
+            }
+            if (props.containsKey('exclusions')) {
+                props['exclusions'].each { String spec ->
+                    def parsed = spec.split(':')
+                    managedDependencyExclusions["${groupId}:${artifactId}"].add([
+                            group: parsed[0],
+                            module: parsed[1],
+                    ])
+                }
+            }
+        }
+    }
+}
+
+allprojects {
+    ext {
+        managedVersions = managedDependencyVersions
+    }
+}
+
+def dependencyManagementProjects = projectsWithFlags('dependencyManagement')
+assert !dependencyManagementProjects.isEmpty() // Guaranteed by settings-flags.gradle
+def dependencyManagementProject = dependencyManagementProjects[0]
+
+configure(dependencyManagementProject) {
+    apply plugin: 'java-platform'
+    apply plugin: com.github.benmanes.gradle.versions.VersionsPlugin
+
+    repositories {
+        google()
+        // Since we manage plugin versions here too.
+        gradlePluginPortal()
+        mavenCentral()
+    }
+
+    javaPlatform {
+        allowDependencies()
+    }
+
+    dependencies {
+        if (rootProject.ext.dependenciesYaml.containsKey('boms')) {
+            dependenciesYaml['boms'].each {
+                api platform("${it}")
+            }
+        }
+
+        constraints {
+            rootProject.ext.dependenciesYaml.forEach { String key, value ->
+                if (key != 'boms') {
+                    def groupId = key
+                    def artifact = value as Map
+                    artifact.forEach { String artifactId, Map props ->
+                        if (props.containsKey('version')) {
+                            api "${groupId}:${artifactId}:${props['version']}"
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+
+    tasks {
+        dependencyUpdates {
+            revision = 'release'
+
+            resolutionStrategy {
+                componentSelection { rules ->
+                    rules.all { ComponentSelection selection ->
+                        boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'preview'].any { qualifier ->
+                            selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
+                        }
+                        if (rejected) {
+                            selection.reject('Release candidate')
+                        }
+                    }
+                }
+            }
+
+            checkConstraints = true
+
+            // We have downgraded versions for legacy artifacts which versions plugin has no way of handling.
+            // But we can provide a reminder to manually check for updates.
+            doLast {
+                logger.quiet "Don't forget to check the following for updates to legacy version downgrades"
+                managedDependencyOverrides.each { override ->
+                    def (group, artifact, version) = override.split(':')
+                    def parts = version.split('\\.')
+                    if (parts.length >= 2) {
+                        logger.quiet "${artifact} is currently version ${version}"
+                        logger.quiet "https://search.maven.org/search?q=g:${group}%20a:${artifact}%20v:${parts[0]}.${parts[1]}.*\n"
+                    }
+                }
+            }
+        }
+    }
+}
+
+configure(projectsWithFlags('java')) {
+
+    configurations.configureEach { configuration ->
+        configuration.dependencies.whenObjectAdded { dep ->
+            if (dep instanceof org.gradle.api.artifacts.ModuleDependency) {
+                managedDependencyExclusions["${dep.group}:${dep.name}"].each {
+                    exclude it
+                }
+            }
+        }
+    }
+
+    // We need to use afterEvaluate because there is no way to guarantee configuration.canBeResolved and
+    // canBeConsumed are set otherwise.
+    afterEvaluate {
+        // From Boot 2.3.0, productionRuntimeClasspath is newly added and its canBeConsumed is set to true
+        // so change it to false. Otherwise, Gradle can't resolve the dependency in bootJar task
+        // because the version will not be added in the following `Add to resolvable configurations`.
+        // https://github.com/spring-projects/spring-boot/blob/v2.3.0.RELEASE/spring-boot-project/spring-boot-tools/spring-boot-gradle-plugin/src/main/java/org/springframework/boot/gradle/plugin/JavaPluginAction.java#L175-L178
+        def springBootGradlePlugin = plugins.findPlugin('org.springframework.boot')
+        def bootJarTask = tasks.findByName('bootJar')
+        def productionRuntimeClasspathConfig = configurations.findByName('productionRuntimeClasspath')
+        if (springBootGradlePlugin != null && bootJarTask != null && productionRuntimeClasspathConfig != null) {
+            productionRuntimeClasspathConfig.canBeConsumed(false)
+        }
+
+        dependencies {
+            configurations.configureEach { configuration ->
+                // Add to resolvable configurations
+                if (configuration.canBeResolved && !configuration.canBeConsumed) {
+                    add(configuration.name, platform(dependencyManagementProject))
+                }
+
+                // Find version overrides in dependency declaration configurations
+                if (!configuration.canBeResolved && !configuration.canBeConsumed) {
+                    configuration.dependencies.configureEach { dep ->
+                        if (dep instanceof org.gradle.api.artifacts.ExternalDependency) {
+                            if (dep.version != null) {
+                                managedDependencyOverrides.add(String.valueOf("${dep.module}:${dep.version}"))
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+// Create a new configuration called 'allDependencies'.
+rootProject.configurations {
+    allDependencies {
+        visible = false
+        transitive = false
+    }
+}
+
+rootProject.ext {
+    // Build the relocation table from dependencies.yml.
+    relocations = dependenciesYaml.entrySet().inject([]) { list, Map.Entry<String, Object> entry ->
+        if (entry.key != 'boms') {
+            def groupId = entry.key
+            entry.value.forEach { String artifactId, Map props ->
+                if (props.containsKey('relocations')) {
+                    props.get('relocations').each {
+                        list.add([
+                                name: "${groupId}:${artifactId}",
+                                from: it['from'],
+                                to: it['to']])
+                    }
+                }
+            }
+        }
+        return list
+    }
+
+    // Build the Javadoc link table from dependencies.yml.
+    javadocLinks = dependenciesYaml.entrySet().inject([]) { list, Map.Entry<String, Object> entry ->
+        if (entry.key != 'boms') {
+            def groupId = entry.key
+            entry.value.forEach { String artifactId, Map props ->
+                if (props.containsKey('javadocs')) {
+                    props['javadocs'].each { url ->
+                        list.add([
+                                groupId: groupId,
+                                artifactId: artifactId,
+                                url: url
+                        ])
+                    }
+                }
+            }
+        }
+        return list
+    }
+}
+
+subprojects {
+    ext {
+        dependenciesYaml = rootProject.ext.dependenciesYaml
+        relocations = rootProject.ext.relocations
+        javadocLinks = rootProject.ext.javadocLinks
+    }
+}
+
+configure(rootProject) {
+    task managedVersions(
+            group: 'Build',
+            description: 'Generates the file that contains dependency versions.') {
+
+        def f = file("${project.buildDir}/managed_versions.yml")
+        inputs.properties managedDependencyVersions
+        outputs.file(f)
+
+        doLast {
+            f.parentFile.mkdir()
+            f.withWriter('UTF-8') {
+                new Yaml().dump(managedDependencyVersions, it)
+            }
+        }
+    }
+}
diff --git a/lib/common-dependencies.gradle b/lib/common-dependencies.gradle
index a363e663a..c6a193e3a 100644
--- a/lib/common-dependencies.gradle
+++ b/lib/common-dependencies.gradle
@@ -13,57 +13,14 @@ buildscript {
     }
 }
 
-rootProject.ext {
-    def dependenciesYamlFile = new File("${project.projectDir}/dependencies.yml")
-    if (dependenciesYamlFile.exists()) {
-        dependenciesYaml = Collections.unmodifiableMap(new Yaml().loadAs(dependenciesYamlFile.text, Map))
-    } else {
-        dependenciesYaml = Collections.emptyMap()
-    }
-}
-
-def managedDependencyVersions = new TreeMap<String, String>() {
-    @Override
-    String get(Object key) {
-        def value = super.get(key)
-        if (value != null) {
-            return value
-        } else {
-            throw new IllegalArgumentException("Missing managed dependency: ${key}")
-        }
-    }
-}
-def managedDependencyExclusions = [:].withDefault { [] }
 def managedDependencyOverrides = [] as Set
-rootProject.ext.dependenciesYaml.forEach { String key, value ->
-    if (key == 'boms') {
-        value.each {
-            def parsed = it.split(':')
-            managedDependencyVersions["${parsed[0]}:${parsed[1]}"] = parsed[2]
-        }
-    } else {
-        def groupId = key
-        def artifact = value as Map
-        artifact.forEach { String artifactId, Map props ->
-            if (props.containsKey('version')) {
-                managedDependencyVersions["${groupId}:${artifactId}"] = String.valueOf(props['version'])
-            }
-            if (props.containsKey('exclusions')) {
-                props['exclusions'].each { String spec ->
-                    def parsed = spec.split(':')
-                    managedDependencyExclusions["${groupId}:${artifactId}"].add([
-                            group: parsed[0],
-                            module: parsed[1],
-                    ])
-                }
-            }
-        }
-    }
-}
 
-allprojects {
+allprojects { p ->
     ext {
-        managedVersions = managedDependencyVersions
+        // Add managedVersions() for backward compatibility with dependencies.yml
+        managedVersions = getManagedVersions(p.rootProject)
+        findLibrary = this.&findLibrary.curry(p.rootProject)
+        findPlugin = this.&findPlugin.curry(p.rootProject)
     }
 }
 
@@ -87,28 +44,14 @@ configure(dependencyManagementProject) {
     }
 
     dependencies {
-        if (rootProject.ext.dependenciesYaml.containsKey('boms')) {
-            dependenciesYaml['boms'].each {
-                api platform("${it}")
-            }
-        }
-
-        constraints {
-            rootProject.ext.dependenciesYaml.forEach { String key, value ->
-                if (key != 'boms') {
-                    def groupId = key
-                    def artifact = value as Map
-                    artifact.forEach { String artifactId, Map props ->
-                        if (props.containsKey('version')) {
-                            api "${groupId}:${artifactId}:${props['version']}"
-                        }
-                    }
-                }
+        rootProject.ext.dependenciesTomlBoms.each { alias ->
+            def library = rootProject.ext.findLibrary(alias)
+            if (library != null) {
+                api platform(library)
             }
         }
     }
 
-
     tasks {
         dependencyUpdates {
             revision = 'release'
@@ -150,8 +93,8 @@ configure(projectsWithFlags('java')) {
     configurations.configureEach { configuration ->
         configuration.dependencies.whenObjectAdded { dep ->
             if (dep instanceof org.gradle.api.artifacts.ModuleDependency) {
-                managedDependencyExclusions["${dep.group}:${dep.name}"].each {
-                    exclude it
+                rootProject.ext.exclusions["${dep.group}:${dep.name}"].each { list ->
+                    list.each { exclude it }
                 }
             }
         }
@@ -201,67 +144,91 @@ rootProject.configurations {
     }
 }
 
-rootProject.ext {
-    // Build the relocation table from dependencies.yml.
-    relocations = dependenciesYaml.entrySet().inject([]) { list, Map.Entry<String, Object> entry ->
-        if (entry.key != 'boms') {
-            def groupId = entry.key
-            entry.value.forEach { String artifactId, Map props ->
-                if (props.containsKey('relocations')) {
-                    props.get('relocations').each {
-                        list.add([
-                                name: "${groupId}:${artifactId}",
-                                from: it['from'],
-                                to: it['to']])
-                    }
+configure(rootProject) {
+    task managedVersions(
+            group: 'Build',
+            description: 'Generates the file that contains dependency versions.') {
+
+        inputs.property("catalog", project.extensions.getByType(VersionCatalogsExtension))
+        def f = file("${project.buildDir}/managed_versions.yml")
+        outputs.file(f)
+
+        doLast {
+            f.parentFile.mkdir()
+            managedVersions = [:]
+            inputs.properties["catalog"].catalogNames.forEach { name ->
+                def catalog = catalogs.named(name)
+                versions = [:] withDefault { [] }
+                catalog.libraryAliases.forEach { alias ->
+                    def library = catalog.findLibrary(alias).get().get()
+                    versions["libraries"].add([alias: alias, module: library.toString])
                 }
-            }
-        }
-        return list
-    }
 
-    // Build the Javadoc link table from dependencies.yml.
-    javadocLinks = dependenciesYaml.entrySet().inject([]) { list, Map.Entry<String, Object> entry ->
-        if (entry.key != 'boms') {
-            def groupId = entry.key
-            entry.value.forEach { String artifactId, Map props ->
-                if (props.containsKey('javadocs')) {
-                    props['javadocs'].each { url ->
-                        list.add([
-                                groupId: groupId,
-                                artifactId: artifactId,
-                                url: url
-                        ])
-                    }
+                catalog.pluginAliases.forEach { alias ->
+                    def plugin = catalog.findPlugin(alias).get().get()
+                    versions["plugins"].add([alias: alias, plugin: plugin.toString])
                 }
+
+                catalog.versionAliases.forEach { alias ->
+                    def version = catalog.findVersion(alias).get()
+                    versions["versions"].add([alias: alias, version: version])
+                }
+
+                catalog.bundleAliases.forEach { alias ->
+                    def bundle = catalog.findBundle(alias).get().get()
+                    versions["bundles"].add([alias: alias, bundle: bundle.toString])
+                }
+                managedVersions[name] = versions
+            }
+
+            f.withWriter('UTF-8') {
+                new Yaml().dump(managedVersions, it)
             }
         }
-        return list
     }
 }
 
-subprojects {
-    ext {
-        dependenciesYaml = rootProject.ext.dependenciesYaml
-        relocations = rootProject.ext.relocations
-        javadocLinks = rootProject.ext.javadocLinks
+static def findLibrary(Project rootProject, String alias) {
+    def catalogs = rootProject.extensions.getByType(VersionCatalogsExtension)
+    def catalog = catalogs.named("libs")
+
+    def library = catalog.findLibrary(alias)
+    if (library.isEmpty()) {
+        return null
+    } else {
+        return library.get()
     }
 }
 
-configure(rootProject) {
-    task managedVersions(
-            group: 'Build',
-            description: 'Generates the file that contains dependency versions.') {
+static def findPlugin(Project rootProject, String alias) {
+    def catalogs = rootProject.extensions.getByType(VersionCatalogsExtension)
+    def catalog = catalogs.named("libs")
 
-        def f = file("${project.buildDir}/managed_versions.yml")
-        inputs.properties managedDependencyVersions
-        outputs.file(f)
+    def plugin = catalog.findPlugin(alias)
+    if (plugin.isEmpty()) {
+        return null
+    } else {
+        return plugin.get()
+    }
+}
 
-        doLast {
-            f.parentFile.mkdir()
-            f.withWriter('UTF-8') {
-                new Yaml().dump(managedDependencyVersions, it)
-            }
+/**
+ * Returns the managed versions that associates a module with a version.
+ * This method is added to support backward compatibility with 'dependencies.yml'
+ * Note that it is not recommended to use `managedVersions` with the module defined multiple times with different
+ * aliases. Because if a module is declared with different versions, the version returned by `managedVersions`
+ * is determined by how the version catalogs are indexed.
+ */
+static def getManagedVersions(Project rootProject) {
+    def managedVersions = [:]
+    def catalogs = rootProject.extensions.getByType(VersionCatalogsExtension)
+    catalogs.catalogNames.forEach { name ->
+        def catalog = catalogs.named(name)
+        catalog.libraryAliases.forEach {
+            def library = catalog.findLibrary(it).get().get()
+            def module = library.module
+            managedVersions["${module.group}:${module.name}"] = library.versionConstraint.requiredVersion
         }
     }
+    return managedVersions
 }
diff --git a/lib/java-alpn.gradle b/lib/java-alpn.gradle
index 20290f142..c1b37bcbf 100644
--- a/lib/java-alpn.gradle
+++ b/lib/java-alpn.gradle
@@ -14,7 +14,7 @@ configure(projectsWithFlags('java')) {
         }
 
         dependencies {
-            alpnAgent 'org.mortbay.jetty.alpn:jetty-alpn-agent'
+            alpnAgent "org.mortbay.jetty.alpn:jetty-alpn-agent:${managedVersions['org.mortbay.jetty.alpn:jetty-alpn-agent']}"
         }
 
         task copyAlpnAgent(type: Copy) {
diff --git a/lib/scala.gradle b/lib/scala.gradle
index c1013919c..27bbdcaf7 100644
--- a/lib/scala.gradle
+++ b/lib/scala.gradle
@@ -58,12 +58,10 @@ configure(scala212 + scala213 + scala3) {
 
 configure(scala212) {
     dependencies {
-        implementation('org.scala-lang:scala-library') {
-            version {
-                strictly '2.12.15'
-            }
+        implementation('org.scala-lang:scala-library:2.12.15')
+        if (managedVersions.containsKey('org.scalameta:munit_2.12')) {
+            testImplementation "org.scalameta:munit_2.12:${managedVersions['org.scalameta:munit_2.12']}"
         }
-        testImplementation 'org.scalameta:munit_2.12'
     }
     tasks.withType(ScalaCompile) {
         scalaCompileOptions.with {
@@ -78,8 +76,10 @@ configure(scala212) {
 
 configure(scala213) {
     dependencies {
-        implementation 'org.scala-lang:scala-library'
-        testImplementation 'org.scalameta:munit_2.13'
+        implementation 'org.scala-lang:scala-library:2.13.8'
+        if (managedVersions.containsKey('org.scalameta:munit_2.13')) {
+            testImplementation "org.scalameta:munit_2.13:${managedVersions['org.scalameta:munit_2.13']}"
+        }
     }
     tasks.withType(ScalaCompile) {
         scalaCompileOptions.with {
@@ -90,8 +90,10 @@ configure(scala213) {
 
 configure(scala3) {
     dependencies {
-        implementation 'org.scala-lang:scala3-library_3'
-        testImplementation 'org.scalameta:munit_3'
+        implementation "org.scala-lang:scala3-library_3:${managedVersions['org.scala-lang:scala3-library_3']}"
+        if (managedVersions.containsKey('org.scalameta:munit_3')) {
+            testImplementation "org.scalameta:munit_3:${managedVersions['org.scalameta:munit_3']}"
+        }
     }
     tasks.withType(ScalaCompile) {
         scalaCompileOptions.with {
diff --git a/settings-flags.gradle b/settings-flags.gradle
index c3f96e850..2c13b7dde 100644
--- a/settings-flags.gradle
+++ b/settings-flags.gradle
@@ -4,6 +4,10 @@ import java.util.concurrent.ConcurrentHashMap
 
 import static java.util.Objects.requireNonNull
 
+// version catalogs should be defined in the settings.gradle or directly imported files.
+// https://docs.gradle.org/current/userguide/platforms.html#sub:version-catalog-declaration
+apply from: "${rootDir}/gradle/scripts/version-catalogs.gradle"
+
 // Ensure the Gradle version first of all.
 GradleVersion minimumSupportedGradleVersion = GradleVersion.version('6.0')
 if (GradleVersion.current() < minimumSupportedGradleVersion) {
diff --git a/version-catalogs.gradle b/version-catalogs.gradle
new file mode 100644
index 000000000..ac22c28a2
--- /dev/null
+++ b/version-catalogs.gradle
@@ -0,0 +1,285 @@
+import org.tomlj.Toml
+import org.tomlj.TomlTable
+import org.tomlj.TomlArray
+
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'org.tomlj:tomlj:1.0.0'
+    }
+}
+
+def dependenciesTomlFile = new File("${rootProject.projectDir}/dependencies.toml")
+if (dependenciesTomlFile.exists()) {
+    def dependenciesYamlFile = new File("${rootProject.projectDir}/dependencies.yml")
+    if (dependenciesYamlFile.exists()) {
+        logger.quiet "Both 'dependencies.toml' and 'dependencies.yml' exist. " +
+                "'dependencies.toml' takes precedence over 'dependencies.yml'"
+    }
+
+    def dependenciesToml = Collections.unmodifiableMap(Toml.parse(dependenciesTomlFile.text).toMap())
+    def metadata = [:]
+    def boms = []
+
+    dependencyResolutionManagement {
+        versionCatalogs {
+            create("libs") { libs ->
+                dependenciesToml.forEach { String key, value ->
+                    def map = value.toMap()
+                    switch (key) {
+                        case "versions":
+                            map.forEach { alias, version -> addVersion(libs, alias, version) }
+                            break
+                        case "libraries":
+                            map.forEach { alias, dependency -> addLibrary(libs, alias, dependency, metadata) }
+                            break
+                        case "bundles":
+                            map.forEach { alias, modules -> addBundle(libs, alias, modules) }
+                            break
+                        case "plugins":
+                            map.forEach { alias, plugin -> addPlugin(libs, alias, plugin) }
+                            break
+                        case "boms":
+                            map.forEach { alias, dependency -> addBom(libs, alias, dependency, boms) }
+                            break
+                        default:
+                            throw new IllegalStateException("Unknown version catalog: '$key'. " +
+                                    "(expected: one of 'versions', 'libraries', 'bundles', 'plungins' and 'boms')")
+                    }
+                }
+            }
+        }
+    }
+
+    gradle.projectsLoaded {
+        def exclusions = [:].withDefault { [] }
+        def relocations = []
+        def javadocLinks = []
+        metadata.forEach { alias, map ->
+            def rel = map.get("relocations")
+            if (rel != null) {
+                relocations.addAll(rel)
+            }
+
+            def ex = map.get("exclusions")
+            if (ex != null) {
+                ex.each {
+                    exclusions[it["name"]].add(ex["exclusion"])
+                }
+            }
+
+            def javadocs = map.get("javadocs")
+            if (javadocs != null) {
+                javadocLinks.addAll(javadocs)
+            }
+        }
+
+        gradle.allprojects { p ->
+            p.ext.hasDependenciesToml = true
+            p.ext.dependenciesTomlBoms = boms
+            p.ext.exclusions = exclusions
+            p.ext.relocations = relocations
+            p.ext.javadocLinks = javadocLinks
+        }
+    }
+} else {
+    gradle.projectsLoaded {
+        gradle.rootProject { p ->
+            p.ext.hasDependenciesToml = false
+            p.ext.dependenciesTomlMetadata = Collections.emptyMap()
+            p.ext.dependenciesTomlBoms = Collections.emptyList()
+        }
+    }
+}
+
+static def addVersion(VersionCatalogBuilder libs, String alias, String version) {
+    libs.version(alias, version)
+}
+
+static def addBom(VersionCatalogBuilder libs, String alias, TomlTable dependency, List<String> boms) {
+    def version = dependency["version"]
+    alias = "boms-" + alias
+    if (version instanceof String) {
+        def library = newLibrary(libs, alias, dependency)["lib"]
+        library.version(version)
+        boms.add(alias)
+        return
+    } else if (version instanceof TomlTable) {
+        if (version.contains("ref")) {
+            def library = newLibrary(libs, alias, dependency)["lib"]
+            library.versionRef(version["ref"])
+            boms.add(alias)
+            return
+        }
+    }
+
+    throw new IllegalStateException("An invalid BOM version on ${alias}: ${dependency.toJson()}" +
+            " (expected: 'version' or 'version.ref')")
+}
+
+static def addLibrary(VersionCatalogBuilder libs, String alias, TomlTable dependency,
+                      Map<String, Map> dependenciesMetadata) {
+    def result = newLibrary(libs, alias, dependency)
+    def library = result.lib
+
+    def version = dependency["version"]
+    if (version == null) {
+        library.withoutVersion()
+    } else if (version instanceof String) {
+        library.version(version)
+    } else if (version instanceof TomlTable) {
+        if (version.contains("ref")) {
+            library.versionRef(version["ref"])
+        } else {
+            library.version {
+                if (version.contains("require")) {
+                    require(version["require"])
+                }
+                if (version.contains("strictly")) {
+                    strictly(version["strictly"])
+                }
+                if (version.contains("prefer")) {
+                    prefer(version["prefer"])
+                }
+                if (version.contains("reject")) {
+                    def rejected = version["reject"]
+                    if (rejected instanceof TomlArray) {
+                        reject(rejected.toList() as String[])
+                    } else {
+                        reject(rejected)
+                    }
+                }
+                if (version["rejectAll"]) {
+                    rejectAll()
+                }
+            }
+        }
+    }
+
+    def metadata = extractMetadata(dependency, result.group, result.artifact, alias)
+    if (!metadata.isEmpty()) {
+        dependenciesMetadata[alias] = metadata
+    }
+}
+
+static def newLibrary(VersionCatalogBuilder libs, String alias, TomlTable dependency) {
+    if (dependency.contains("group") && dependency.contains("name")) {
+        def group = dependency["group"]
+        def artifact = dependency["name"]
+        return [lib: libs.library(alias, group, artifact), group: group, artifact: artifact]
+    } else if (dependency.contains("module")) {
+        def module = dependency["module"].split(":")
+        if (module.length != 2) {
+            throw new IllegalStateException("An invalid module declaration on ${alias}: ${module} (expected: 'groupId:artifactId')");
+        }
+        def group = module[0]
+        def artifact = module[1]
+        return [lib: libs.library(alias, group, artifact), group: group, artifact: artifact]
+    } else {
+        throw new IllegalStateException("An invalid library declaration on ${alias}: ${dependency.toJson()}" +
+                " (expected: 'module' or 'group' and 'name')")
+    }
+}
+
+static Map<String, Object> extractMetadata(TomlTable dependency, String group, String artifact, String alias) {
+    def metadata = [:]
+    def javadocs = dependency["javadocs"]
+    if (javadocs != null) {
+        if (javadocs instanceof String) {
+            metadata["javadocs"] = [[groupId: group, artifactId: artifact, url: javadocs]]
+        } else if (javadocs instanceof TomlArray) {
+            metadata["javadocs"] = javadocs.toList().collect {
+                [groupId: group, artifactId: artifact, url: it]
+            }
+        } else {
+            throw new IllegalStateException("An invalid javadoc links on ${alias}: $javadocs'" +
+                    " (expected: A string or an array of strings)")
+        }
+    }
+
+    def module = "$group:$artifact"
+    def exclusions = dependency["exclusions"]
+    if (exclusions != null) {
+        if (exclusions instanceof String) {
+            def excluded = exclusions.split(":")
+            metadata["exclusions"] = [[name: module, exclusion: [group: excluded[0], module: excluded[1]]]]
+        } else if (exclusions instanceof TomlArray) {
+            metadata["exclusions"] = exclusions.toList().collect {
+                def excluded = it.split(":")
+                [name: module, exclusion: [group: excluded[0], module: excluded[1]]]
+            }
+        } else {
+            throw new IllegalStateException("An invalid exclusions on ${alias}: $exclusions" +
+                    " (expected: A string or an array of strings)")
+        }
+    }
+
+    def relocations = dependency["relocations"]
+    if (relocations != null) {
+        if (relocations instanceof TomlTable) {
+            metadata["relocations"] = [[name: module, from: relocations["from"], to: relocations["to"]]]
+        } else if (relocations instanceof TomlArray) {
+            metadata["relocations"] = relocations.toList().collect {
+                [name: module, from: it["from"], to: it["to"]]
+            }
+        } else {
+            throw new IllegalStateException("An invalid relocations on ${alias}: $relocations" +
+                    " (expected: A map or an array of maps)")
+        }
+    }
+    metadata
+}
+
+static def addBundle(VersionCatalogBuilder libs, String alias, List<String> aliases) {
+    libs.bundle(alias, aliases)
+}
+
+static def addPlugin(VersionCatalogBuilder libs, String alias, TomlTable plugin) {
+    def version = plugin['version']
+    if (version instanceof TomlTable) {
+        def ref = version["ref"]
+        if (ref == null) {
+            throw new IllegalStateException("An invalid plugin declaration on $alias: ${version.toJson()}")
+        }
+        libs.plugin(alias, plugin["id"]).versionRef(ref)
+    } else {
+        libs.plugin(alias, plugin["id"]).version(plugin['version'])
+    }
+}
+
+gradle.projectsLoaded {
+    gradle.rootProject { p ->
+        // Prints all versions registered through 'dependencies.toml'
+        p.tasks.register("printVersionCatalogs") {
+            def catalogs = p.extensions.getByType(VersionCatalogsExtension)
+            doLast {
+                catalogs.catalogNames.forEach { name ->
+                    def catalog = catalogs.named(name)
+                    catalog.libraryAliases.forEach {
+                        def library = catalog.findLibrary(it).get().get()
+                        println "$name / library / $it / $library"
+                    }
+
+                    catalog.pluginAliases.forEach {
+                        def plugin = catalog.findPlugin(it).get().get()
+                        println "$name / plugin / $it / $plugin"
+                    }
+
+                    catalog.versionAliases.forEach {
+                        def version = catalog.findVersion(it).get()
+                        println "$name / version / $it / $version"
+                    }
+
+                    catalog.bundleAliases.forEach {
+                        def bundle = catalog.findBundle(it).get().get()
+                        println "$name / bundle / $it / $bundle"
+                    }
+                }
+            }
+        }
+
+    }
+}
